# DCO (Developer Certificate of Origin) Check Workflow
# Ensures all commits have proper DCO sign-off

name: DCO Check

on:
  pull_request:
    branches: [ main, 'dev/**' ]
  push:
    branches: [ main, 'dev/**' ]

permissions:
  contents: read
  pull-requests: write
  statuses: write

jobs:
  dco-check:
    name: Verify DCO Sign-off
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Environment
      run: |
        echo "CHECK_DATE=$(date +%Y-%m-%d)" >> $GITHUB_ENV
        echo "COMMITS_CHECKED=0" >> $GITHUB_ENV
        echo "VALID_COMMITS=0" >> $GITHUB_ENV
        echo "INVALID_COMMITS=0" >> $GITHUB_ENV

    # DCO Validation for Pull Requests
    - name: DCO Check for Pull Request
      if: github.event_name == 'pull_request'
      run: |
        echo "üîç Checking DCO sign-off for pull request commits..."
        
        # Get the list of commits in this PR
        base_sha="${{ github.event.pull_request.base.sha }}"
        head_sha="${{ github.event.pull_request.head.sha }}"
        
        echo "Checking commits between $base_sha and $head_sha"
        
        # Get commit list
        commits=$(git rev-list --reverse "$base_sha..$head_sha")
        
        if [ -z "$commits" ]; then
          echo "‚ö†Ô∏è No commits found in this PR"
          exit 0
        fi
        
        invalid_commits=""
        valid_count=0
        total_count=0
        
        for commit in $commits; do
          total_count=$((total_count + 1))
          echo "Checking commit: $commit"
          
          # Get commit message
          commit_msg=$(git log --format=%B -n 1 "$commit")
          
          # Check for DCO sign-off line
          if echo "$commit_msg" | grep -qE "^Signed-off-by: .+ <.+@.+\..+>$"; then
            echo "‚úÖ Commit $commit has valid DCO sign-off"
            valid_count=$((valid_count + 1))
            
            # Verify sign-off matches author
            author_email=$(git log --format=%ae -n 1 "$commit")
            author_name=$(git log --format=%an -n 1 "$commit")
            signoff_line=$(echo "$commit_msg" | grep "^Signed-off-by:" | tail -1)
            
            if echo "$signoff_line" | grep -q "$author_email"; then
              echo "‚úÖ Sign-off email matches author email"
            else
              echo "‚ö†Ô∏è Sign-off email doesn't match author email"
              echo "   Author: $author_name <$author_email>"
              echo "   Sign-off: $signoff_line"
            fi
          else
            echo "‚ùå Commit $commit missing DCO sign-off"
            invalid_commits="$invalid_commits\n- $commit"
          fi
        done
        
        echo "COMMITS_CHECKED=$total_count" >> $GITHUB_ENV
        echo "VALID_COMMITS=$valid_count" >> $GITHUB_ENV
        echo "INVALID_COMMITS=$((total_count - valid_count))" >> $GITHUB_ENV
        
        if [ "$valid_count" -ne "$total_count" ]; then
          echo "‚ùå DCO validation failed"
          echo "Total commits: $total_count"
          echo "Valid commits: $valid_count"
          echo "Invalid commits: $((total_count - valid_count))"
          echo -e "Commits missing DCO sign-off:$invalid_commits"
          exit 1
        fi
        
        echo "‚úÖ All commits have valid DCO sign-off"

    # DCO Validation for Push to Main
    - name: DCO Check for Push
      if: github.event_name == 'push'
      run: |
        echo "üîç Checking DCO sign-off for pushed commits..."
        
        # Check the last few commits
        commits=$(git rev-list HEAD~10..HEAD 2>/dev/null || git rev-list HEAD)
        
        if [ -z "$commits" ]; then
          echo "‚ö†Ô∏è No commits found"
          exit 0
        fi
        
        invalid_commits=""
        valid_count=0
        total_count=0
        
        for commit in $commits; do
          total_count=$((total_count + 1))
          echo "Checking commit: $commit"
          
          # Get commit message
          commit_msg=$(git log --format=%B -n 1 "$commit")
          
          # Check for DCO sign-off line
          if echo "$commit_msg" | grep -qE "^Signed-off-by: .+ <.+@.+\..+>$"; then
            echo "‚úÖ Commit $commit has valid DCO sign-off"
            valid_count=$((valid_count + 1))
          else
            echo "‚ùå Commit $commit missing DCO sign-off"
            invalid_commits="$invalid_commits\n- $commit"
          fi
        done
        
        echo "COMMITS_CHECKED=$total_count" >> $GITHUB_ENV
        echo "VALID_COMMITS=$valid_count" >> $GITHUB_ENV
        echo "INVALID_COMMITS=$((total_count - valid_count))" >> $GITHUB_ENV
        
        if [ "$valid_count" -ne "$total_count" ]; then
          echo "‚ùå DCO validation failed for push"
          echo -e "Commits missing DCO sign-off:$invalid_commits"
          exit 1
        fi
        
        echo "‚úÖ All pushed commits have valid DCO sign-off"

    # Validate DCO Format
    - name: Validate DCO Format
      if: github.event_name == 'pull_request'
      run: |
        echo "üìù Validating DCO sign-off format..."
        
        base_sha="${{ github.event.pull_request.base.sha }}"
        head_sha="${{ github.event.pull_request.head.sha }}"
        commits=$(git rev-list --reverse "$base_sha..$head_sha")
        
        format_issues=""
        
        for commit in $commits; do
          commit_msg=$(git log --format=%B -n 1 "$commit")
          signoff_lines=$(echo "$commit_msg" | grep "^Signed-off-by:" || true)
          
          if [ -n "$signoff_lines" ]; then
            while IFS= read -r line; do
              # Validate format: "Signed-off-by: Full Name <email@domain.tld>"
              if ! echo "$line" | grep -qE "^Signed-off-by: [^<]+ <[^@]+@[^@]+\.[^@>]+>$"; then
                echo "‚ùå Invalid DCO format in commit $commit: $line"
                format_issues="$format_issues\n- $commit: $line"
              else
                echo "‚úÖ Valid DCO format in commit $commit"
              fi
            done <<< "$signoff_lines"
          fi
        done
        
        if [ -n "$format_issues" ]; then
          echo "‚ùå DCO format validation failed"
          echo -e "Format issues:$format_issues"
          echo ""
          echo "Valid format example:"
          echo "Signed-off-by: John Doe <john.doe@example.com>"
          exit 1
        fi
        
        echo "‚úÖ All DCO sign-offs have proper format"

    # Check for Multiple Sign-offs
    - name: Check Multiple Sign-offs
      if: github.event_name == 'pull_request'
      run: |
        echo "üë• Checking for multiple contributors..."
        
        base_sha="${{ github.event.pull_request.base.sha }}"
        head_sha="${{ github.event.pull_request.head.sha }}"
        commits=$(git rev-list --reverse "$base_sha..$head_sha")
        
        for commit in $commits; do
          commit_msg=$(git log --format=%B -n 1 "$commit")
          signoff_count=$(echo "$commit_msg" | grep "^Signed-off-by:" | wc -l)
          
          if [ "$signoff_count" -gt 1 ]; then
            echo "üë• Commit $commit has multiple sign-offs (collaborative commit)"
            echo "$commit_msg" | grep "^Signed-off-by:"
          fi
        done
        
        echo "‚úÖ Multiple sign-off check completed"

    # Generate DCO Report
    - name: Generate DCO Report
      if: always()
      run: |
        echo "üìã Generating DCO check report..."
        
        cat > dco-report.md << EOF
        # DCO Sign-off Report
        
        **Date:** ${{ env.CHECK_DATE }}
        **Commit:** ${GITHUB_SHA:0:8}
        **Branch:** ${{ github.ref_name }}
        **Event:** ${{ github.event_name }}
        
        ## Validation Results
        
        - **Commits Checked:** ${{ env.COMMITS_CHECKED }}
        - **Valid Commits:** ${{ env.VALID_COMMITS }}
        - **Invalid Commits:** ${{ env.INVALID_COMMITS }}
        
        ## Checks Performed
        
        - ‚úÖ DCO sign-off presence
        - ‚úÖ DCO format validation
        - ‚úÖ Author/sign-off consistency
        - ‚úÖ Multiple contributor detection
        
        ## DCO Requirements
        
        Every commit must include a valid DCO sign-off:
        \`\`\`
        Signed-off-by: Your Name <your.email@example.com>
        \`\`\`
        
        ## How to Add DCO Sign-off
        
        ### For new commits:
        \`\`\`bash
        git commit -s -m "Your commit message"
        \`\`\`
        
        ### For existing commits:
        \`\`\`bash
        git commit --amend --signoff
        \`\`\`
        
        ### For multiple commits:
        \`\`\`bash
        git rebase -i HEAD~N --signoff
        \`\`\`
        
        ---
        *Automated DCO check by GitHub Actions*
        EOF
        
        echo "‚úÖ DCO report generated"

    # Upload DCO Report
    - name: Upload DCO Report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: dco-report-${{ env.CHECK_DATE }}
        path: dco-report.md
        retention-days: 30

    # Set Status Check
    - name: Set DCO Status
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const state = ${{ env.INVALID_COMMITS }} > 0 ? 'failure' : 'success';
          const description = ${{ env.INVALID_COMMITS }} > 0 
            ? `${process.env.INVALID_COMMITS} commits missing DCO sign-off`
            : `All ${process.env.VALID_COMMITS} commits properly signed`;
          
          if (context.eventName === 'pull_request') {
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              state: state,
              target_url: `${context.payload.pull_request.html_url}/checks`,
              description: description,
              context: 'DCO Check'
            });
          }

    # Comment DCO results on PR
    - name: Comment DCO Results
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const invalidCommits = parseInt('${{ env.INVALID_COMMITS }}');
          const validCommits = parseInt('${{ env.VALID_COMMITS }}');
          const totalCommits = parseInt('${{ env.COMMITS_CHECKED }}');
          
          let comment;
          
          if (invalidCommits > 0) {
            comment = `
            ## ‚ùå DCO Sign-off Check Failed
            
            **${invalidCommits}** out of **${totalCommits}** commits are missing DCO sign-off.
            
            ### How to Fix
            
            Add DCO sign-off to commits using one of these methods:
            
            #### For the last commit:
            \`\`\`bash
            git commit --amend --signoff
            git push --force-with-lease
            \`\`\`
            
            #### For multiple commits:
            \`\`\`bash
            git rebase -i HEAD~${totalCommits} --signoff
            git push --force-with-lease
            \`\`\`
            
            #### For future commits:
            \`\`\`bash
            git config --global commit.gpgsign true
            git commit -s -m "Your message"
            \`\`\`
            
            ### What is DCO?
            
            The Developer Certificate of Origin (DCO) is a legal statement that you have the right to submit your contribution. Add this line to your commit messages:
            
            \`\`\`
            Signed-off-by: Your Name <your.email@example.com>
            \`\`\`
            
            üìö See [DCO.md](https://github.com/swm-sink/dev-platform/blob/main/DCO.md) for detailed instructions.
            `;
          } else {
            comment = `
            ## ‚úÖ DCO Sign-off Check Passed
            
            All **${validCommits}** commits have valid DCO sign-off.
            
            ‚úÖ **DCO Compliance:** All commits properly signed  
            ‚úÖ **Format Validation:** Sign-off format is correct  
            ‚úÖ **Author Consistency:** Sign-offs match commit authors  
            
            Thank you for following the contribution guidelines! üéâ
            `;
          }
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });